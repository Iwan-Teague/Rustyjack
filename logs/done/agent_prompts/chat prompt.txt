Date: 2026-02-15

You are a senior Rust networking engineer. You have full local access to this Rust codebase (Pi Zero 2 W target) and can run tests/builds. Your job is to implement the improvements described below as a clean, reviewable patch series.

NON-NEGOTIABLE CONSTRAINTS
- Do NOT add new offensive functionality or optimize/extend disruptive behavior.
- Do NOT provide instructions for real-world abuse. Treat all “offensive ops” as existing features that must be capability-gated, made safer, and made more predictable.
- No new third-party *system binaries* to “fix” things (keep to Rust + kernel interfaces). Small Rust crate additions are allowed only if absolutely necessary; prefer using existing deps.
- The device is a Pi Zero 2 W and the product goal is “absolute control”: only project-authorized services. Preserve privilege separation (UI unprivileged, daemon privileged) and harden it further.

DELIVERABLES
1) A short design note (in markdown) explaining:
   - What you changed and why
   - Key tradeoffs
   - How to test (commands + expected outcomes)
2) A patch series (multiple commits) with:
   - Clear commit messages
   - Tests for new logic where feasible
   - Updated docs / UI copy where relevant
3) For each requested change area, follow this pipeline in your write-up:
   - Is it a problem? Why?
   - Where is it (exact files/functions)?
   - What is the fix (precise behavior + code shape)?
   - What does “fixed” look like (before/after behaviors)?

PROJECT CONTEXT (you must confirm in code)
- There is a shared “wizard” style runner for operations in the UI; most operations route through it.
- There is a “capabilities” model for wireless interfaces, currently too optimistic about injection.
- There is an isolation/enforcement step that tries to enforce single interface usage.
- Several operations mutate system networking state (nftables, sysctls, interface modes) and must reliably clean up on error/cancel.

IMPLEMENTATION TASKS (in priority order)

A) Fix wireless capability detection (monitor ≠ injection)
Goal: Make capability reporting truthful, deterministic, and hardware-aware.
1. In the capability query layer, stop equating “supports_injection = supports_monitor”.
2. Add explicit detection for “active monitor mode” / TX-in-monitor where the kernel exposes it.
   - Use nl80211 feature flags when available.
3. Add a conservative policy:
   - Default injection/TX-in-monitor to false/unknown unless proven.
   - Add a driver/firmware-aware denylist (e.g., brcmfmac class) unless a known patched capability is detected.
4. Update UI preflight gates to match backend requirements exactly:
   - If an operation needs monitor, require monitor.
   - If it needs TX-in-monitor/injection, require that, not just monitor.
5. Update user-facing messages:
   - Explain “monitor mode does not imply injection”.

Acceptance criteria:
- On unsupported hardware (esp. onboard Pi Wi-Fi without proven TX-in-monitor), disruptive ops are blocked early with a clear reason.
- On supported adapters, preflight matches runtime behavior (no “it said yes but fails instantly”).

B) Introduce an explicit “Operation Resource Request” model + planner
Goal: Remove ad-hoc capability checks & reduce inconsistent failures.
1. Define a typed resource request structure used by each operation, e.g.:
   - needs_wifi: { monitor: bool, ap: bool, tx_in_monitor: bool, count: 1|2 }
   - needs_privileges: CAP_NET_ADMIN, raw sockets, etc.
   - needs_storage: loot write
   - needs_network_mutations: nftables/sysctl
2. Implement a single “planner/resolver” that:
   - selects interface(s)
   - validates capabilities
   - enforces isolation consistent with the request
   - returns a structured plan, or a structured denial reason
3. Refactor operations to declare needs and consume the plan rather than re-deriving everything themselves.

Acceptance criteria:
- Multi-role ops either:
  - run with a clearly documented “single-radio limited mode”, OR
  - fail fast with a crisp “requires 2 Wi-Fi interfaces (AP + monitor)” message.
- Isolation no longer contradicts operation needs.

C) Make cleanup transactional and cancellation-safe (RAII)
Goal: Any operation that mutates system networking must always restore state.
1. Implement a small transaction/rollback framework for network mutations:
   - Every mutation registers a compensating action
   - Rollback runs on error and on cancellation
2. Use RAII (“Drop”) to guarantee best-effort cleanup even when early returns happen.
3. Ensure cancellation paths trigger rollback and leave a clean system state:
   - nftables rules restored
   - sysctls restored
   - interface modes restored where possible
4. Add integration-style tests where feasible (or at least unit tests for the transaction stack + deterministic rollback ordering).

Acceptance criteria:
- Repeated start/stop/cancel cycles do not accumulate nftables rules or leave forwarding/DNS altered.
- A forced failure mid-operation still restores state.

D) Unify wizard workflow and remove legacy divergence
Goal: “All ops go through the same runner” becomes true in practice.
1. Identify any operations still dispatched through legacy app flows.
2. Migrate them to the unified OperationRunner path.
3. Ensure consistent UX:
   - preflight → setup → confirm → run → results
   - structured errors surfaced uniformly (capabilities vs auth vs stealth vs approval gate)

Acceptance criteria:
- One common workflow for all operations.
- One common error model displayed consistently.

E) Harden systemd units & privilege boundaries
Goal: Maintain required privileges for the daemon while reducing blast radius.
1. Review existing unit files for UI/daemon/portal.
2. Apply systemd hardening directives where compatible:
   - NoNewPrivileges=yes (where possible)
   - ProtectSystem=strict (or at least full)
   - PrivateTmp=yes
   - ProtectKernelTunables/Logs/Modules where viable
   - CapabilityBoundingSet to the minimal needed set (daemon may need CAP_NET_ADMIN; UI should need none)
3. Document any directives you can’t enable due to required functionality.

Acceptance criteria:
- Services run with the least privileges feasible and are sandboxed.
- No regression in required operation behavior.

F) Add a “Hardware Profile” view/report
Goal: Make the device’s true Wi-Fi capabilities obvious to the operator.
1. Implement a command that outputs:
   - driver name, chipset if detectable
   - supported interface modes (station/AP/monitor)
   - nl80211 feature flags relevant to monitor TX/injection
   - your derived capability verdict + reasons (e.g., “tx_in_monitor: false because …”)
2. Surface it in UI (read-only) and include it in logs.

Acceptance criteria:
- Operators immediately see whether onboard Wi-Fi can do required modes.
- Debugging “why was I blocked?” becomes trivial.

REFERENCE NOTES (use these to ground decisions; don’t paste giant excerpts)
- Linux wireless nl80211/mac80211/cfg80211 documentation; monitor/injection nuances and interface modes.
- Active monitor mode detection via nl80211 feature flag (where supported).
- Rust RAII/Drop for cleanup guarantees.
- systemd hardening options in systemd.exec.

PROCESS REQUIREMENTS
- Work in small commits. After each commit, run tests/build. If tests are missing, add targeted tests.
- Prefer refactors that reduce duplication and make invariants explicit.
- Output at the end:
  (1) design note, (2) list of commits with summaries, (3) key files changed, (4) test instructions, (5) any known limitations.

Now begin by:
1) Printing a repo map (crates/modules relevant to ops runner, wireless capability queries, isolation, nftables/sysctl mutations, systemd units).
2) Proposing the patch plan (commit-by-commit).
3) Implementing tasks A→F in order, with tests and docs updates.
