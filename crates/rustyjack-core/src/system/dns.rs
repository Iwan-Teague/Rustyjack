use anyhow::{Context, Result};
use std::fs::{self, OpenOptions};
use std::io::Write;
use std::net::Ipv4Addr;
use std::path::PathBuf;
use tracing::{debug, info};

pub struct DnsManager {
    resolv_path: PathBuf,
}

impl DnsManager {
    pub fn new(resolv_path: PathBuf) -> Self {
        Self { resolv_path }
    }

    pub fn set_dns(&self, servers: &[Ipv4Addr]) -> Result<()> {
        info!("Setting DNS servers: {:?}", servers);

        if servers.is_empty() {
            return Ok(());
        }

        let mut content = String::new();
        content.push_str("# Generated by Rustyjack\n");
        content.push_str("# Do not edit manually\n\n");

        for server in servers {
            content.push_str(&format!("nameserver {}\n", server));
        }

        let temp_path = self.resolv_path.with_extension("tmp");

        {
            #[cfg(unix)]
            use std::os::unix::fs::OpenOptionsExt;

            #[cfg(unix)]
            let mut file = OpenOptions::new()
                .write(true)
                .create(true)
                .truncate(true)
                .mode(0o644)
                .open(&temp_path)
                .context("failed to open temp resolv.conf")?;

            #[cfg(not(unix))]
            let mut file = OpenOptions::new()
                .write(true)
                .create(true)
                .truncate(true)
                .open(&temp_path)
                .context("failed to open temp resolv.conf")?;

            file.write_all(content.as_bytes())
                .context("failed to write temp resolv.conf")?;

            file.sync_all().context("failed to sync temp resolv.conf")?;
        }

        fs::rename(&temp_path, &self.resolv_path).context("failed to rename resolv.conf")?;

        debug!("DNS configuration written successfully");
        Ok(())
    }

    pub fn verify_dns(&self) -> Result<Vec<Ipv4Addr>> {
        let content =
            fs::read_to_string(&self.resolv_path).context("failed to read resolv.conf")?;

        let mut servers = Vec::new();

        for line in content.lines() {
            let line = line.trim();
            if line.starts_with("nameserver") {
                if let Some(ip_str) = line.split_whitespace().nth(1) {
                    if let Ok(ip) = ip_str.parse::<Ipv4Addr>() {
                        servers.push(ip);
                    }
                }
            }
        }

        Ok(servers)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_dns_set_and_verify() {
        let temp_dir = TempDir::new().unwrap();
        let resolv_path = temp_dir.path().join("resolv.conf");
        let dns = DnsManager::new(resolv_path);

        let servers = vec![Ipv4Addr::new(8, 8, 8, 8), Ipv4Addr::new(1, 1, 1, 1)];

        dns.set_dns(&servers).unwrap();

        let result = dns.verify_dns().unwrap();
        assert_eq!(result.len(), 2);
        assert!(result.contains(&Ipv4Addr::new(8, 8, 8, 8)));
        assert!(result.contains(&Ipv4Addr::new(1, 1, 1, 1)));
    }

    #[test]
    fn test_dns_empty_servers() {
        let temp_dir = TempDir::new().unwrap();
        let resolv_path = temp_dir.path().join("resolv.conf");
        let dns = DnsManager::new(resolv_path.clone());

        // Setting empty should be no-op
        dns.set_dns(&[]).unwrap();

        // File should not exist
        assert!(!resolv_path.exists());
    }

    #[test]
    fn test_dns_overwrite() {
        let temp_dir = TempDir::new().unwrap();
        let resolv_path = temp_dir.path().join("resolv.conf");
        let dns = DnsManager::new(resolv_path);

        let servers1 = vec![Ipv4Addr::new(8, 8, 8, 8)];
        dns.set_dns(&servers1).unwrap();

        let servers2 = vec![Ipv4Addr::new(1, 1, 1, 1)];
        dns.set_dns(&servers2).unwrap();

        let result = dns.verify_dns().unwrap();
        assert_eq!(result.len(), 1);
        assert_eq!(result[0], Ipv4Addr::new(1, 1, 1, 1));
    }

    #[test]
    fn test_dns_single_server() {
        let temp_dir = TempDir::new().unwrap();
        let resolv_path = temp_dir.path().join("resolv.conf");
        let dns = DnsManager::new(resolv_path);

        let servers = vec![Ipv4Addr::new(8, 8, 8, 8)];
        dns.set_dns(&servers).unwrap();

        let result = dns.verify_dns().unwrap();
        assert_eq!(result.len(), 1);
        assert_eq!(result[0], Ipv4Addr::new(8, 8, 8, 8));
    }
}
