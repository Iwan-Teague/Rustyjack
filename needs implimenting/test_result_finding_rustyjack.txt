Got it. I unpacked the project zip and the test-result bundle and walked through the failing suites by correlating:

the suite run.log files in the results bundle,

the JSON artifacts the tests try to parse,

the Bash test harness scripts in scripts/,

and the Rust implementations in the workspace crates.

Below is what I’ve confirmed so far (with concrete root causes), plus the exact files/areas that need changes. I’m also being explicit about what’s still incomplete: I did not get to write the final “downloadable” .md file as an actual separate file artifact in this response, but I am providing the full Markdown content you can paste into a file and use immediately. The summary and raw logs I based this on are in the uploaded documents:

What failed, and why (high-confidence findings)
1) Discord Webhook suite: JSON output is polluted by logs → parsing fails

Fail: discord_send_succeeded

Observed behavior: The artifact file that is supposed to be pure JSON contains log lines before the JSON. The test harness uses a strict JSON reader (python -c 'json.load(...)') so it returns empty fields and declares failure.

Root cause: The Rust CLI logging pipeline writes logs to stdout. The tests capture stdout into a .json file. So logs + JSON = invalid JSON.

Where this originates: The CLI initialization uses tracing_subscriber::fmt() without configuring the writer; fmt defaults to stdout (docs confirm fmt logs to stdout by default).
Reference: tracing_subscriber fmt overview (logs to stdout) — https://recursion.wtf/tracing-honeycomb/tracing_subscriber/fmt/index.html

Fix: Route tracing logs to stderr (standard convention: “data on stdout, diagnostics on stderr”).
Also consider disabling ANSI colors when not a TTY (optional).

Files to change:

crates/rustyjack-core/src/main.rs (logging init)

2) USB Mount suite: same JSON pollution issue → multiple failures

Fails:

usb_detectability_preflight checks

usb_mount_command_ok, usb_mount_mountpoint_present, usb_mount_not_readonly etc.

Same issue: logs printed on stdout corrupt the JSON artifact files.

Fix is the same as Discord: log to stderr.

Files to change: same: crates/rustyjack-core/src/main.rs

3) Ethernet suite: ethernet discover loot filename includes “/24” → invalid path

Fail: eth_discover_eth0 (rc=1)
Error indicates it tried to write to:

/var/lib/rustyjack/loot/Ethernet/discovery_192.168.18.0/24_YYYYMMDD_HHMMSS.txt

The slash in the CIDR becomes a directory separator, so the file open fails.

Root cause: handle_eth_discover uses the raw Ipv4Net string in a filename.

Fix: Sanitize the string (replace / with _). There is already a helper sanitize_label() in rustyjack-core/src/system/mod.rs that does exactly this.

Files to change:

crates/rustyjack-core/src/operations.rs → handle_eth_discover

4) Wireless suite: wifi scan fails because it enforces strict interface isolation during a “read-only” operation

Fails:

wifi_scan_wlan0 / wifi_scan_wlan1 (rc=1)

Isolation snapshot comparisons also fail because routes change

Root cause (two layers):

handle_wifi_scan unconditionally calls system.enforce_single_interface(&interface) which performs destructive actions on other interfaces (DHCP release, flushing addresses, deleting default routes, rfkill changes). That breaks the test’s “read-only should not mutate network state” invariant.

The isolation implementation currently deletes default routes too broadly (see next item), which is why you see route snapshot diffs.

Fix direction:

Make wifi scan not enforce isolation by default. Add an explicit flag if you want isolation (e.g. --isolate) but default must be non-destructive.

Ensure no net-state mutations for read-only commands, or restore state (RAII guard) if you must temporarily change link state.

Files to change:

crates/rustyjack-core/src/operations.rs → handle_wifi_scan (remove unconditional isolation)

5) Default-route deletion bug: “delete default route for interface” actually deletes all default routes

This is one of the sneaky systemic issues that amplifies failures across suites.

Root cause:
NetOps::delete_default_route(&self, iface: &str) ignores iface and calls a netlink helper that deletes all default routes. That’s why blocking wlan0 can delete the default route that actually belongs to eth0, and vice versa.

Where it is:

crates/rustyjack-core/src/system/ops.rs → RealNetOps::delete_default_route calls netlink_delete_default_route() which is currently global.

crates/rustyjack-core/src/netlink_helpers.rs → netlink_delete_default_route() has no interface parameter.

crates/rustyjack-netlink/src/route.rs currently has a global delete_default_route() (and also has more precise helpers like delete_conflicting_default_routes used by replace_default_route).

Fix:

Add an interface-scoped delete routine in rustyjack-netlink (filter default routes by RTA_OIF / interface index) and expose it.

Update core netlink helpers + RealNetOps::delete_default_route to call the scoped version.

Keep a separate helper for “delete all default routes” where needed.

This will reduce route flapping and eliminate a big class of unintended network disruptions.

Files to change:

crates/rustyjack-netlink/src/route.rs (add delete_default_routes_on_interface)

crates/rustyjack-core/src/netlink_helpers.rs (split “delete all” vs “delete per iface”)

crates/rustyjack-core/src/system/ops.rs (use the per-iface delete)

6) Daemon / IPC + Interface Selection + Deep Daemon: socket “listening” but file path missing → all RPC fails

Fails: huge number of RPC calls with FileNotFoundError: /run/rustyjack/rustyjackd.sock

Key evidence: ss/lsof show the daemon/systemd holds a listening unix socket named /run/rustyjack/rustyjackd.sock, but the filesystem path check fails ([[ -S ... ]] fails). That pattern is consistent with the socket inode still existing while the directory entry has been removed/unlinked.

Most likely root cause (systemd behavior):
The combination of:

socket unit: ListenStream=/run/rustyjack/rustyjackd.sock

service unit: also manages /run/rustyjack via RuntimeDirectory=rustyjack

…can lead to systemd recreating/cleaning the runtime dir in a way that removes the socket entry, leaving the open inode alive but unreachable by pathname.

This isn’t hypothetical: systemd has long-standing discussions about socket-unit directory ownership/management, and there’s also a known limitation that socket units can set DirectoryMode but parent directories default to root ownership, leading to awkward patterns.
Reference: systemd issue on parent directory ownership for socket units — https://github.com/systemd/systemd/issues/4125

Fix direction (practical and robust):

Do not have the service manage the same runtime directory that hosts the socket file, or ensure it never cleans/unlinks the socket entry.

Recommended: remove RuntimeDirectory=rustyjack from the service unit and instead ensure /run/rustyjack is created via:

a tmpfiles rule (/etc/tmpfiles.d/rustyjack.conf), OR

the socket unit only (but note parent directory ownership limitations; tmpfiles is the clean fix).

Ensure directory ownership is root:rustyjack with mode 0770, so group members can traverse and connect.

Files to change:

services/rustyjackd.service (stop managing the same runtime dir, or set preserve semantics)

Add: tmpfiles.d config (not a binary; system facility)

Installer scripts to install tmpfiles config and run systemd-tmpfiles --create

7) Daemon causes “route changed” failures by temporarily removing default routes (race vs snapshots)

This hits daemon suite, encryption suite, theme suite, usb_mount suite, etc.

Even if the final state is “reasonable”, the test snapshots can catch the system in the short window where the daemon has deleted a route and not yet re-added it.

Root cause: In crates/rustyjack-core/src/system/routing.rs, set_default_route* is implemented as “delete then add” instead of a replace/keep-if-matching strategy.

You already have a correct idempotent netlink primitive: rustyjack_netlink::replace_default_route, used elsewhere in system/mod.rs. The routing manager should use the same approach so it never creates a “no-default-route” window.

Fix:

Update RoutingManager::set_default_route and set_default_route_with_metric to:

no-op if the correct default route already exists, or

call the netlink-level replace helper (atomic-ish and idempotent).

Files to change:

crates/rustyjack-core/src/system/routing.rs

8) Evasion suite: randomize MAC fails due to RF-kill state

Fail: evasion_mac_randomize

Observed: it errors when bringing wlan0 up: “Operation not possible due to RF-kill”.

Underlying cause: Earlier failures (especially strict isolation attempts during wifi scans) leave rfkill or interface state altered. The MAC randomizer also doesn’t attempt to unblock rfkill before toggling link state.

Fix:

In handle_evasion_randomize_mac, call an “ensure rfkill unblocked” helper for wireless interfaces before trying to bring them up.

Also: avoid calling strict isolation for read-only commands so they don’t leave rfkill blocked in the first place.

Files to change:

crates/rustyjack-core/src/operations.rs (evasion handler)

Optionally: crates/rustyjack-evasion/src/mac.rs if you want it lower-level and reusable

9) Hotspot suite: script crashes immediately (rc=127) due to missing Bash function

The hotspot test script calls rj_detect_wifi_interface, but that function is not defined in rj_test_lib.sh or anywhere else.

Because the script is set -euo pipefail, it exits immediately.

Fix:

Implement rj_detect_wifi_interface in scripts/rj_test_lib.sh (or modify hotspot script to use existing detection logic).

Keep it minimal: choose first interface with /sys/class/net/*/wireless present.

Files to change:

scripts/rj_test_lib.sh (add function)

or scripts/rj_test_hotspot.sh (avoid calling undefined)

10) Theme/Palette suite: UI navigation indices are wrong → it never reaches Colors menu

The test script navigates main menu using down 9, but the current UI main_menu() has Settings at index 10, not 9. So the script selects the wrong menu and never triggers theme mutation, so gui_conf.json stays unchanged.

Fix: Update the scripted navigation:

change “down 9” → “down 10” in ui_nav_main_to_colors_menu.

Files to change:

scripts/rj_test_theme.sh

(There is also a “route changed” failure in the theme suite which should be solved by fixing daemon route flapping as described above.)

11) Installers suite: two installer scripts missing required steps/patterns

install_rustyjack.sh and install_rustyjack_dev.sh fail pattern checks for:

purge network-manager

disable_conflicting_services()

claim_resolv_conf()

logging “Running post install checks”

log dir chown line

Those checks are purely grep-based and your prebuilt installer already contains these patterns; the wrapper scripts don’t.

Fix: Make the wrapper scripts include and call the same functions (or inline the required functions and lines). The tests require those literal strings to appear in the script files.

Files to change:

install_rustyjack.sh

install_rustyjack_dev.sh

Markdown file you can save (copy/paste)

Below is a complete .md you can save as something like TEST_FAILURES_AND_FIX_PLAN.md. It includes the file-level changes and recommended patch shapes.

NOTE: I’m providing this as inline Markdown because I can’t emit a separate downloadable file artifact in this response. Everything here is formatted to be saved directly.

# RustyJack – Pi Zero W2 Test Failures & Fix Plan (2026-02-20)

## Context
- Device: Raspberry Pi Zero W2
- Tests executed over SSH via Ethernet
- Results analyzed from:
  - `rustyjack_20260220-140515_summary.md`
  - `rustyjack_20260220-140515_all_logs.txt`
  - results bundle `20260220-140515/*`

## High-level Root Causes (Most Impact)
1. **Logs written to stdout corrupt JSON outputs** used by multiple suites.
2. **Interface isolation invoked during read-only commands** (wifi scan, ethernet discover) causing network mutations and failures.
3. **Default route deletion bug:** “delete route for iface” deletes all default routes.
4. **Daemon unix socket path missing** (socket appears listening but filesystem entry absent) → RPC fails.
5. **Daemon routing changes are non-idempotent (delete then add)** → snapshot race sees route changes.
6. **Bash script issues** (hotspot missing function; theme navigation index drift).
7. **Installer wrappers missing required logic/patterns**.

---

## Suite-by-suite: What Failed and Why

### Discord Webhook
- Fail: `discord_send_succeeded`
- Cause: stdout logs precede JSON output; parser fails.
- Fix: move tracing logs to stderr.

### USB Mount
- Multiple failures that depend on reading JSON output.
- Cause: same stdout log pollution.
- Additional: route snapshot diffs likely due to daemon route flapping.
- Fix: stderr logs + daemon routing idempotence.

### Ethernet
- Fail: `eth_discover_eth0`
- Cause: loot filename uses CIDR string `192.168.18.0/24` → `/` becomes a path separator.
- Fix: sanitize label when building filenames.
- Also: route snapshot diffs caused by isolation enforcement and/or daemon route flapping.

### Wireless
- Fail: `wifi_scan_wlan0`, `wifi_scan_wlan1` (rc=1)
- Cause: `wifi scan` enforces strict interface isolation (brings other interfaces down, releases DHCP, rfkill changes). This can:
  - violate isolation invariants in a managed networking environment,
  - mutate routes and break “read-only snapshot” expectations.
- Fix: do NOT enforce strict isolation for `wifi scan` by default. Optional `--isolate` flag if desired.

### Evasion
- Fail: `evasion_mac_randomize`
- Cause: wlan interface soft-blocked by rfkill (likely left behind by earlier strict isolation failures); randomize-mac doesn’t unblock.
- Fix: ensure rfkill unblocked before MAC changes; reduce rfkill side effects from read-only commands.

### Daemon / Interface Selection / Deep Daemon
- Many RPC calls fail with FileNotFoundError for `/run/rustyjack/rustyjackd.sock`.
- Cause: socket inode exists but path entry missing/unlinked. Likely runtime directory management conflicts with socket unit.
- Fix: adjust systemd units + runtime directory creation strategy.

### Encryption / Theme / USB Mount route diffs
- Cause: daemon routing logic temporarily removes default route (delete then add), so snapshot races see route change.
- Fix: route updates must be idempotent/replace-based (never create a “no default route” window).

### Hotspot
- Script exits (rc=127) because `rj_detect_wifi_interface` is undefined.
- Fix: implement function in `scripts/rj_test_lib.sh` or update hotspot script.

### Installers
- Wrapper installers missing required patterns/steps.
- Fix: copy/inline the common functions and required log lines.

---

## Fix Plan (Detailed)

## 1) Stop corrupting JSON output: send logs to stderr

### Change
`crates/rustyjack-core/src/main.rs`

#### Before
```rust
tracing_subscriber::fmt()
  .with_env_filter(filter)
  .init();
After
tracing_subscriber::fmt()
  .with_env_filter(filter)
  .with_writer(std::io::stderr) // key change
  .with_ansi(atty::is(atty::Stream::Stderr)) // optional but recommended
  .init();
Why

The test harness captures stdout into .json artifact files; logs must never share that channel.

2) Fix ethernet discovery loot filename sanitization
Change

crates/rustyjack-core/src/operations.rs in handle_eth_discover

Before
let file_name = format!("discovery_{}_{}.txt", net, timestamp);
After
let safe_net = crate::system::sanitize_label(&net.to_string());
let file_name = format!("discovery_{}_{}.txt", safe_net, timestamp);
3) Remove strict isolation from read-only commands (wifi scan, ethernet discover)
WiFi Scan

crates/rustyjack-core/src/operations.rs in handle_wifi_scan

Before
system.enforce_single_interface(&interface)?;
After (default no isolation; optional flag)

Add CLI arg: --isolate default false.

Only enforce isolation if args.isolate == true.

Pseudocode:

if args.isolate {
  system.enforce_single_interface(&interface)?;
}
Ethernet Discover

handle_eth_discover currently enforces single interface.
Remove it; discovery should not reconfigure other links.

4) Fix default route deletion semantics (per-interface, not global)
Problem

NetOps::delete_default_route(iface) currently deletes ALL default routes.

Changes

In crates/rustyjack-netlink/src/route.rs:

Add delete_default_routes_on_interface(iface_name: &str):

map iface name -> ifindex

iterate default routes and delete only those where RTA_OIF == ifindex

In crates/rustyjack-core/src/netlink_helpers.rs:

Split helpers:

netlink_delete_all_default_routes()

netlink_delete_default_routes_on_interface(iface: &str)

In crates/rustyjack-core/src/system/ops.rs:

RealNetOps::delete_default_route(&self, iface) calls the interface-scoped helper.

5) Make routing idempotent to stop snapshot races
Problem

crates/rustyjack-core/src/system/routing.rs uses delete-then-add which creates a time window with no default route.

Fix

Use rustyjack_netlink::replace_default_route() (already present and used elsewhere) or “no-op if correct route already exists”.

Pseudocode:

fn set_default_route_with_metric(...) {
  // 1) if default route already matches iface+gateway(+metric), return Ok(())
  // 2) else call replace_default_route(gateway, ifindex, metric)
}

Result: daemon enforcement can run periodically without causing observable route changes.

6) Fix daemon socket path disappearance (systemd runtime dir conflict)
Likely cause

Service manages /run/rustyjack via RuntimeDirectory=rustyjack while socket unit binds a socket under the same path. The directory management can remove/unlink the socket entry while the inode remains open.

Fix options (preferred: tmpfiles)

Remove RuntimeDirectory=rustyjack from services/rustyjackd.service.

Ensure /run/rustyjack exists with correct ownership/mode via tmpfiles:

Add services/tmpfiles.d/rustyjack.conf:

d /run/rustyjack 0770 root rustyjack -

Installer must install this file to /etc/tmpfiles.d/ and run:

systemd-tmpfiles --create

Also ensure socket unit keeps:

ListenStream=/run/rustyjack/rustyjackd.sock

SocketGroup=rustyjack

SocketMode=0660

DirectoryMode=0770

7) RF-kill robustness for MAC randomization
Change

crates/rustyjack-core/src/operations.rs in handle_evasion_randomize_mac

Before calling mac_manager.set_mac(...):

detect rfkill idx for the interface (reuse rfkill_find_index)

if soft blocked, unblock

if hard blocked, return a clear error

Pseudocode:

if let Some(idx) = rfkill_find_index(&iface) {
  let state = rfkill_get_state(idx)?;
  if state.hard_blocked { bail!("...hard blocked...") }
  if state.soft_blocked { rfkill_set_state(idx, false)?; }
}
8) Hotspot test script fix
Change

scripts/rj_test_lib.sh
Add:

rj_detect_wifi_interface() {
  for d in /sys/class/net/*; do
    iface="$(basename "$d")"
    [[ -d "$d/wireless" ]] && { echo "$iface"; return 0; }
  done
  return 1
}
9) Theme test script fix (menu index drift)
Change

scripts/rj_test_theme.sh
In ui_nav_main_to_colors_menu, update:

rj_ui_send down 9 → rj_ui_send down 10

This matches current UI main_menu() where Settings is the 11th entry.

10) Installer wrapper scripts: add missing steps/patterns
Change

install_rustyjack.sh

install_rustyjack_dev.sh

They must include:

a purge network-manager section (literal text match)

disable_conflicting_services() { ... }

claim_resolv_conf() { ... }

print Running post install checks

chown -R rustyjack-ui:rustyjack ...logs

Best approach: copy the same function bodies from install_rustyjack_prebuilt.sh so behavior is consistent.

Security/Hardening Notes

Keep structured output strict: JSON must always be clean and machine-parseable.

Prefer idempotent netlink operations (replace vs delete+add) to avoid transient connectivity loss.

Avoid destructive isolation for informational commands; require explicit opt-in for “lockdown” behaviors.

Ensure systemd sandbox exceptions (ReadWritePaths) align with how files are written (avoid temp file rename across bind mounts if you later harden /etc).

Quick Regression Checklist

After applying fixes:

rustyjack notify discord send --output json emits ONLY JSON on stdout.

rustyjack usb-mount mount ... --output json emits ONLY JSON on stdout.

rustyjack ethernet discover creates loot files with sanitized names.

rustyjack wifi scan succeeds with eth0 up and does not change routes by default.

/run/rustyjack/rustyjackd.sock exists and is connectable by intended group users.

route snapshots remain stable while daemon is running.


---

## What I did *not* complete in this response (transparent gaps)
- I didn’t produce a separate downloadable `.md` file artifact (the content is complete and ready to save, but not emitted as a file attachment here).
- I didn’t implement and validate the patches by running the suite again (I can’t re-run on the Pi from here). The fixes are derived directly from the failing logs and the code paths that produced them, so the confidence is high.
- I didn’t fully design an “isolation rollback guard” (RAII state restoration) for strict isolation failures; I focused on removing strict isolation from read-only commands and fixing the route semantics that cause most trouble. If you want the isolation machinery to be safer under errors, adding a rollback guard is the next logical hardening step.

---

## Primary evidence used
- Summary of failures:   
- Full consolidated logs:   
- Upstream references:
  - tracing_subscriber fmt logs to stdout by default: https://recursion.wtf/tracing-honeycomb/tracing_subscriber/fmt/index.html
  - systemd socket parent directory ownership limitation: https://github.com/systemd/systemd/issues/4125

---

If you paste that Markdown into a file and want it turned into **a patch series (diffs)** against the repo, I can structure the changes as a clean commit plan: “logging,” “netlink routing,” “daemon systemd units,” “script fixes,” etc., with minimal cross-churn.
::contentReference[oaicite:4]{index=4}